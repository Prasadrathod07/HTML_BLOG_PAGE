<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First Project</title>
</head>
<body>
   <h1>Backtracking</h1> 
   <p>Backtracking is the form of recursion.</p>
   <p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Magni odit magnam cupiditate odio, nam libero voluptate debitis modi illo exercitationem, placeat quod fugit rerum oneee<br>
   similique voluptatibus minus deserunt error est harum, numquam quas? Iste eos, sit asperiores ullam omnis nesciunt. Lorem, ipsum dolor sit amet consectetur adipisicing elit. twoooooo<br>
   Omnis harum aspernatur ipsa molestiae soluta, illo quod deserunt eius. Eum quia officiis reprehenderit nesciunt molestias necessitatibus repudiandae provident odit itaque quasthere<br>
laboriosam suscipit possimus,soluta.</p>
<p>
    Lorem ipsum dolor, sit amet consectetur adipisicing elit. Libero incidunt eaque mollitia voluptas hic illum aut, maxime veniam repudiandae totam, natus enim sit facere quo repellat
    delectus?<br> Beatae dolor placeat dignissimos. Dolores veritatis in, culpa aperiam dolorem ea, sed, eum id quod adipisci saepe ab reiciendis? Quas molestias ut corrupti repellat consequatur
     provident<br> qui autem repudiandae dolore iure vande mataram, bharatmata ki jay. ab kya likhe kuch samaj.
</p>
<p>
    Lorem ipsum dolor sit amet consectetur, adipisicing elit. Deserunt facilis praesentium molestias eveniet animi, facere quos labore porro ea ullam mollitia necessitatibus eaque sint. Omnis dolore<br>
     aperiam possimus excepturi saepe cum porro, in obcaecati corrupti aut officia quasi dolorem ea. Suscipit veniam consectetur autem accusamus tempora quia excepturi nesciunt cum ratione od<br>sit
      labore, mollitia ab veritatis ut, consequatur okay come with me cumque.yes this is random text ,this doesnot will matter.jai hind ore mere desh tu jindabad rahe kab hoga ye.
</p><br>
<p>This need an example
</p>
<img src="./projectpic1.png" height="160px" width="300px">
<ol>
    <li>Lorem ipsum, dolor sit amet consectetur adipisicing elit. Reprehenderit, vel!</li><br>
    <li>Lorem ipsum, dolor sit amet consectetur adipisicing Reprehenderit</li><br>
    <li>Lorem ipsum, dolor sit amet  elit.</li><br>
    <li>Lorem ipsum, dolor sit amet consectetur adipisicing elit. Reprehenderit</li><br>
    <li>dolor sit amet consectetur adipisicing elit.</li><br>
    <li>Lorem ipsum, dolor amet consectetur adipisicing Reprehenderit, !</li><br>
    <li>Lorem ipsum, dolor sit amet consectetur  elit.vel!</li><br>
    <li>Lorem ipsum, dolor sit amet consectetur </li><br>

</ol>
<p> <strong>dolor sit amet consectetur adipisicing elit. Commodi molestiae dignissimos eius accusamus sint exercitationem sunt corporis, non ratione hare ram ram ram
    quod, deserunt maiores quibusdam eligendi cupiditate provident illo labore quisquam quos reiciendis magnam, aspernatur quasi. Ipsum sit molestiae hare krishna kri
    laboriosam distinctio veritatis veniam numquam qui, odio voluptatum quaerat in modi neque accusantium, ducimus tempora iusto et maxime ad,shna hare hare</p></strong><hr>
    <br>



    <!------------------------------------backtracking algorithems--------------------------------------------->

    <h3>The Backtracking algorithm.</h3>
   <pre style="color: rgb(16, 174, 174);">
    boolean solvable (Node n) {

        if n is a leaf node{
            if the leaf is a goal node,return true
            else return false
        } else {
            for each child c of n{
                if solve(c) succeeds,return true
            }
            return false
           }
    
        }
        
   </pre>
    <p><strong>
        Lorem ipsum dolor sit amet consectetur adipisicing elit. Officia, odio harum ipsam saepe nemo architecto adipisci alias cumque neque dolor quidem, libero in 
        iure voluptate ratione sit nesciunt totam ea nulla rem earum explicabo quam debitis? Perferendis totam dolorem asperiores molestiae nam vero debitis hic magni, 
        praesentium reprehenderit fuga ab cupiditate fugit omnis accusamus delectus facere nisi quam? Cupiditate tempore nobis corporis voluptatum earum saepe sint?</strong>
    </p><br>
    <p><b>How does this works?</b></p>
    <ul>
        <li>Lorem ipsum, dolor sit amet consectetur adipisicing Reprehenderit, vel!</li><br>
    <li>Lorem ipsum, dolor sit amet consectetur adipisicing  Reprehenderit</li><br>
    
    </ul>
    <p>
        Lorem ipsum dolor sit amet consectetur adipisicing elit. Officia, odio harum ipsam saepe nemo architecto adipisci alias cumque neque dolor quidem, libero in <br>
        iure voluptate ratione sit nesciunt totam ea plicabo quam debitis? Perferendis totam dolorem asperiores molestiae nam <br>

    </p>
    <br><!----------------------------iframmmmmmmmmmm--------------------------------->
   <pre style="color: rgb(23, 184, 184);">
    
for each child c of n{
  if solve(c) succeeds, return true
}
return false

   </pre>
    <br>
    <p>
        Lorem ipsum dolor sit amet consectetur adipisicing elit. Officia, odio harum ipsam saepe nemo architecto adipisci alias cumque neque dolor quidem, libero in <br>
        iure voluptate ratione sit nesciunt totam ea nulla rem earum explicabo quam debitis? Perferendis totam dolorem asperiores.<br>

    </p><br><!--------------------iframeeeeeeeeeeeeeeeeeeeeeeeeeee-->
    <pre style="color: rgb(23, 184, 184);">
        if n is a leaf node {


          If the leaf is a goal node, return true
        
        } else return false
        
           </pre>
    <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Officia, odio harum ipsam saepe nemo architecto adipisci alias cumque neque dolor quidem, libero in </p><br>

    <ul>
        <li><b>To search a tree:</b></li>
    </ul>
    <ol start="1">
        <li>this is my name , my name i prassad rathod from thane ,maharastra</li>
        <li>Lorem ipsum dolor sit, amet consectetur adipisicing elit. Debitis commodi enim hic assumenda quis quas aperiam, laudantium neque inventore eum itaque, sequi <br>dolore soluta est libero repellendus laborum accusamus quibusdam?</li><br>

    </ol>
    <p><b>Non-recursive backtracking , using a stack</b></p>
    <p>Lorem ipsumpiditate, labore non dolor Lorem ipsum dolor, sit amet consectetur adipisicing elit. Doloremque, aperiam. Totam unde, aperiam dignissimos officia, perferendis perspiciatis aut magnam delectus consequuntur deserunt dolores exercitationem. Iure minus reprehenderit eaque sint mollitia!</p>
    <!--------------------------------iframeeeeeeeeeeeeeeeeee-->
    <pre style="color: rgb(23, 184, 184);">
        boolean solve(Node n) {
            put node n on the stack;
             while the stack is not empty           
               if the node at the top of the stack is a leaf {
                 If it is a goal node, return true
                  else pop it off the stack
               }
               else{
            
                 if the node at the top of the stack has untried children push the next untried child onto the stack else pop the node off the stack
            
        } return false
    }
            
        
           </pre>
    <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Sit aspernatur saepe iure maiores quaerat provident ea impedit sint, quam labore, numquam quas optio illum repudiandae tempora omnis
     aliquid suscipit ipsa modi rerum harum nesciunt et? Autem aperiam asperiores saepe omnis facere quos natus voluptatum commodi consectetur distinctio error maxime, minima praesentium magni doloribus
     voluptatibus ratione beatae et a mollitia officia modi vel. Accusantium inventore natus veritatis? Molestias quos iusto, delectus nihil dignissimos minima et eos voluptate sit, quo eius quod, repellat
     neque deleniti illo tenetur placeat laboriosam ea Lorem ipsum dolor sit amet consectetur, adipisicing elit. Quod enim ab, tenetur officiis voluptate assumenda eaque iste architecto eveniet ducimus inmagnam expedita </p>
<br> 
     <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Similique, magnam quos incidunt placeat necessitatibus consectetur quasi, recusandae possimus autem architecto doloremque veniam reprehenderit
        nemo ea. Molestias </p><br>
      <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nam facere dolores temporibus iure voluptatibus dolorem libero, rem quasi modi! Corporis itaque eum est natus dolorum nihil quae cum dolor quia, qui ea odio impedit ipsa facere. Iste culpa autem quis similique, sequi quasi rem dolore molestias. Fugit id esse reprehenderit!Lorem Lorem ipsum dolor sit, amet consectetur adipisicing elit.Fugit, vitae?</p><br>
    <p>Lorem ipsum dolor, sit amet consectetur adipisicing elit. Totam earum perferendis deserunt ducimus eius possimus, architecto esse rem odio facere est voluptas.</p><br>
    <!-----------iframeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee-->
    <pre style="color: rgb(23, 184, 184);">
        boolean solvable (int[] board) {

            if (puzzleSolved (board)) {
            
              return true;
            
            }
            
            for (int position = 0; position < BOARD_SIZE; position++) {
            
              if (canMove(board, position)) {
            
               int[] newBoard = makeMove (board, position);
            
               if (solvable(newBoard)) {
            
                 printBoard (newBoard);
            
              return true;
            
             }
            }
             return false;
            
           }
        }
            
        
           </pre>
    <br>
    <p><b>keeping Backtracking simple</b></p>
    <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Assumenda accusamus provident tempore autem dolore laboriosam quisquam eaque soluta perferendis necessitatibus ducimus ipsa in accusantium nemo,
    libero voluptates labore nihil impedit pariatur minus debitis animi? Laboriosam magni aliquam asperiores eaque voluptatem <br><br>
<br>

    sita dolores ipsum temporibus, quidem et commodi voluptatum minus sapiente saepe cumque consequuntur consectetur sequi laborum rem vero! Ullam eveniet velit, similique impedit distinctio,
    ipsum ut eligendi <br><br>
    
<br>
    aspernatur magnam Suscipit labore animi nam aut officia accusantium accusamus vel necessitatibus ad ipsum. Voluptate odit, nobis magni rem exercitationem ut cumque minus doloremque
    ducimus aperiam repudiandae <span style="font-weight: bold;">dignissimos quis</span> placeat nisi atque optio eius veniam!veritatis dolor porro illum commodi vitae  non? Eos, doloremque beatae voluptate <span style="font-weight: bold;">optio velit </span>molestiae minima distinctio unde
    sequi in perferendis, accusamus dicta debitis repudiandae sit quas, ex corporis<br><br>
     
    <br>
    Maugiat amet deserunt facere tempore repellat molestiae? Sapiente nesciunt blanditiis debitis facere, libero alias commodi veritatis nam a, delectus architecto officiis provident aliquam est fuga sed aspernatur ay the home i
    At laboriosam assumenda nam. Iste, quas? Optio earum et amet tempora vel alias! Dolores voluptates magnam deserunt, adipisci quaerat nemo corporis velit doloribus dolorem qui omnis cumque quas! Neque ratione in quod,none no
    quos, explicabo quibusdam numquam laboriosam nihil natus aspernatur magni repellat aperiam dolorum voluptate aliquam ad maiores iusto adipisci! Repellendus officiis maxime explicabo distinctio. Unde porro exercitationem yes 
    similique eligendi. Vero ab nesciunt delectus consequatur <span style="font-weight: bold;">molestiae eveniet asperiores qui</span> molestiae impedit sequi, veniam possimus sunt, expedita officia  eveniet asperiores qui odio excepturi nobis. Vero impedit, nisi doloremque, aliquam pariatur 
    ipsum voluptates commodi facere doloribus iure est minima, voluptate earum. Facilis hic totam sint, temporibus vel reprehenderit molestias quidem officia ipsa recusandae, ea dignissimos ratione ducimus nemo repellat sed similiqu
    atque veniam porro, harum eligendi vero.<br><br>
     
     <br>

    est asperiores corrupti quis eius dolor debitis doloremque, natus illum quia adipisci praesentium eos ipsa eveniet minus laudantium illo. Qui beatae nobis, sunt cumque, eius tempore ex quam corrupti a culpa, itaque repudiandae!
     Quam sunt voluptatem voluptatum dolorem error iusto praesentium aliquam unde iste rem quidem quas vero soluta sit necessitatibus veritatis, totam cupiditate qui atque voluptate nesciunt incidunt id voluptas. Molestiae, sint! Magnam
    provident incidunt sunt culpa et? Deleniti error quibusdam fugit soluta recusandae mollitia ipsum velit harum aliquam iste. Quam veritatis quos dolorum unde? Impedit ad quo accusamus deserunt sunt dicta nam inventore ducimus, 
     ullam dolores <br><br>
<br>

    nesciunt sequi eaque enim perspiciatis officiis commodi. voluptates illum dolore aperiam quam quis culpa, aliquid explicabo. Aut, nisi odio asperiores ab
    totam neque itaque odit earum adipisci aspernatur quaerat! Provident, quasi cum mollitia culpa earum molestiae inventore assumenda sapiente porro.<br><br>

<br>
    Lorem ipsum dolor sit amet consectetur adipisicing elit. Natus doloremque officiis aliquid voluptatibus<span style="font-weight: bold;">uas esse vitae</span> vel ipsa perspiciatis corporis animi velit repudiandae a cupiditate commodi<span style="font-weight: bold;">laborum at,</span> quia soluta,
    dolore dolores consequuntur accusamus pariatu<span style="font-weight: bold;">rem. Possimus</span> laudantium neque doloremque praesentium quo eveniet, <span style="font-weight: bold;">facilisid quis </span>exercitationem  <span style="font-weight: bold;">officiis</span> minima voluptatum ipsam labore recusandae atque repellat pariatur 
    saepe perferendis asperiores. Ut harum corrupti <span style="font-weight: bold;">dignissimos voluptates expedita ipsam</span>  odit pariatur nostrum ratione non! Sint harum quaerat totam non, sunt neque ducimus? Inventore cum quos ea earum unde, qui saepe accusamus
    mollitia ex. Est, quia! Consequuntur voluptatibus omnis nesciunt, dicta molestiae nobis voluptates eaque perspiciatis impedit quidem minus exercitationem nihil autem adipisci dolore hic quaerat, ipsa necessitatibus, doloremque
    <span style="font-weight:bold">mollitia iusto labore harum! Impedit</span><br><br>


<br>
    totam veritatis unde velit accusamus molestias iusto corporis praesentium? laborum? Perspiciatis? Lorem <span style="font-weight: bold;">dolor sit, amet consectetur</span>  adipisicing elit. Possimus, molestiae accusamus. Sapiente libero accusamus sunt?
    Tempora laudantium sequi, vel consequuntur, nulla impedit architecto eaque labore voluptatum pariatur aspernatur sapiente cum. Lorem ipsum dolor sit amet consectetur adipisicing elit. Distinctio aspernatur, fugiat sed non asperiores 
    saepe sapiente quo nostrum consequatur ipsa. Necessitatibus architecto temporibus nostrum non doloremque natus labore? Dicta, ut?</p><br><br>


<br>

    <p><strong>Example: Tree search</strong></p>
    <p> Architecto neque repellat voluptate totam cum tenetur quidem, impedit iusto quos consectetur voluptatibus alias optio tempora similique! Cupiditate numquam nostrum sequi natus!
    Lorem ipsum dolor, sit amet consectetur adipisicing elit. Architecto </p> <br>
    <p>Lorem ipsum dolor sit, amet consectetur adipisicing elit. Quisquam, nobis, dicta dolores fugit doloremque qui delectus placeat beatae nulla molestias sunt vitae! Natus dolorem, eos ullam tempore nobis commodi. Nisi ratione exercitationem
     quis expedita error eligendi ducimus officia ea. Deleniti, voluptatem. Quaerat ullam vel fugit libero commodi optio nihil non! Quia ad dolor amet voluptas, aliquam dicta quasi expedita magni harum placeat tempora nobis? Eum, ut aspernatur 
     et is consectetur enim est sapiente reprehenderit!lorem85 Lorem, ipsum dolor sit amet consectetur adipisicing elit. At a sed sunt?
      tempore veniam dolorum doloremque maiores eaque minima! Lorem ipsum dolor sit amet consectetur adipisicing elit. Possimus consectetur esse tenetur, accusamus sequi impedit 
      ip Consequuntur enim assumenda atque ratione!
     </p>
     <br>
     <p> Here is the deffination of the binary tree class</p>
     <!------------------------------------------------------------------------iframeeeeeeeeeeee------------>
     <pre style="color: rgb(23, 184, 184);">
        
    public class BinaryTree
        Binary Tree leftChild = null;
        Binary Tree rightChild = null;
        boolean isGoalNode = false;
        String name,
        
        Binary Tree(String name, Binary Tree left, Binary Tree right, boolean isGoalNode) {
            this.name = name;
            leftChild left;
            rightChild right;
            this.isGoalNode isGoalNode;
        }
    


           </pre>
     <p>Next we will create tree search class and in it we will defind to make tree() which construct the abou binary tree</p>
     <!---------------------iframeeeee-->
     <pre style="color: rgb(23, 184, 184);">
       
        static Binary Tree makeTree() {
            Binary Tree root, a, b, c, d, e, f;
            c = new Binary Tree("C", null, null, false);
            d = new Binary Tree("D", null, null, false);
            e = new BinaryTree("E", null, null, true); f = new Binary Tree("F", null, null, false);
            a = new BinaryTree("A", c, d, false);
            b= new Binary Tree("B", e, f, false);
            root = new BinaryTree("Root", a, b, false);
            return root;
            Here's a main program to create a binary tree and try to solve it
            public static void main(String args[]) (
            BinaryTree tree = makeTree();
            System.out.println(solvable(tree));
        }


           </pre>
     <br>
     <p> here is the main progrAM of binary tree class and try to solve it
     </p>
     <br>
     <!-----------iframe--------------------->
     <pre style="color: rgb(23, 184, 184);">
        static boolean solvable(binary tree node){
            /* 1*/ if (node == null) return false;
            /* 2 */ if (node.isGoalNode) return true;
            /3/ if (solvable(node.leftChild)) return true;
            4/ if (solvable(node.rightChild)) return true;
            /* 5 */ return false;

        }
        
           </pre>
     <br>
     <p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Sint minima repellendus numquam dicta animi at possimus nam i</p>
     <pre style="color: rgb(23, 184, 184);">
        
        
           </pre><br>
     <p>here what the numbered lines are doing:</p>
     <ol>
        <li>Lorem ipsum dolor sit amet consectetur adipisicing elit. Aliquam eos ullam in quos est, eius nisi, officiis consequuntur suscipit nemo libero non alias magni dignissimos debitis fuga eveniet magnam iure.
        Lorem ipsum dolor sit amet consectetur adipisicing elit. sequi?</li><br>
        <li>Lorem ipsum dolor sit amet consectetur adipisicing elit.</li><br>
        <li>Lorem, Lorem ipsum dolor sit amet consectetur adipisicing elit. Dolores recusandae, natus maxime perferendis nostrum fuga nisi amet aut non quam cum deleniti beatae, necessitatibus quod animi eos tempora 
            maiores tempore!lorem lorem</li><br>
         <li>Do the same things for the right child</li><br>
         <li>Do the same things for the right child he will be success</li><br>
     </ol>
     <p>Do the same things for the right child he will be successDo the same things for the right child he will be success</p>
     <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Porro nesciunt aperiam, eius in, aspernatur asperiores laudantium consectetur, aliquam consequatur autem sit ratione molestiae optio et quaerat non suscipit obcaecati earum.
    nam animi, aperiam aliquid? Fugiat voluptatum officiis  modi architecto quae deleniti autem dolor id numquam.</p><br>
    <!--------------------------iframe=================-->
    <pre style="color: rgb(23, 184, 184);">
    
        static boolean solvable (Binary Tree node) {

            if (node.isGoalNode) return true;
            
            if (node.leftChild != null && solvable (node.leftChild)) return true;
            
            if (node.rightChild != null && solvable(node.rightChild)) return true;
            
            return false;
            
        
           </pre>
<br>
<p>right child he will be successDo the same things for the right child h</p><hr>
<p><strong>What are the childrens?</strong></p>
<p>Lorem ipsum dolor, sit amet consectetur adipisicing elit. Fugit architecto laboriosam quis, deserunt perspiciatis quos amet? Deserunt tenetur tempora quam perspiciatis alias harum totam modi id, debitis pariatur nostrum nulla quibusdam 
    nam autem nisi ipsa voluptas praesentium unde perferendis ut temporibus reprehenderit? Saepe cupiditate consectetur perspiciatis laboriosam quos repudiandae recusandae nesciunt officiis quam harum reiciendis distinctio voluptate fuga quas
     totam illo minima a dicta enim optio doloremque, porro quo? Quis consequuntur iusto deserunt odit. Veritatis, quisquam beatae officia perspiciatis laborum natus ab distinctio vel. Debitis deserunt accusamus blanditiis nesciunt ullam, laborum 
     placeat eligendi. <br><br>
     Perferendis quis corrupti nisi dignissimos accusamus id ratione officiis tenetur? Maiores itaque obcaecati debitis praesentium ex, consequuntur aut quam voluptatem dolorum ducimus minus ab! Deleniti, sequi quia voluptate quam aspernatur 
     consequuntur sed doloremque quas recusandae eius quod quae error rerum suscipit dolorem ipsam magni harum. Porro consequatur quasi velit laborum placeat quo illum sunt rerum! Facere eveniet tempore dolorem vitae quis minus fuga assumenda!
     Enim aliquid laborum<br><br>
    harum recusandae soluta voluptatem qui voluptate dolor totam vitae veniam maiores dolores ipsam alias excepturi officiis eaque, incidunt sapiente rerum! Recusandae vel natus fuga culpa hic molestias quae nulla suscipit excepturi inventore,
    reprehenderit<br><br></p> <p>there are two way to do this:<br>
    </p>
    <ul>
        <li>Lorem ipsum dolor sit amet consectetur adipisicing elit. Id eveniet assumenda, quidem pariatur suscipit facere commodi cupiditate praesentium, dignissimos asperiores aspernatur quam minus? Optio pariatur alias deleniti quis maiores facilis.</li>
        <li>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Consequatur pariatur eveniet accusantium quia dolores nam, accusamus voluptatum enim officiis cum reiciendis, soluta quam, ratione at ex magnam. Reprehenderit, tempore mollitia.
            Lorem ipsum dolor sit amet consectetur, adipisicing elit</li>
    </ul>
    <br>
    <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam dolorum dignissimos consequuntur? Temporibus recusandae odit quod tenetur blanditiis voluptate deleniti fuga. Officiis aut totam ex nulla tempore obcaecati dignissimos placeat!
    Lorem ipsum dolor sit, amet consectetur adipisicing elit. .</p><br>
    <p><strong>Boolean mapisOK()</strong></p>
    <p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Cumque, exercitationem voluptatum.</p>
    <p><strong>Boolean OKtocolour(in row,int col,int color)</strong></p>
    <p>Lorem,adipisicing elit. Blanditiis, illo quasi omnis, doloribus, maxime cum ut unde numquam minus voluptatum delectus natus perferendis? Nobis, accusamus iure hic ab sapiente et!</p>
    
    <p><strong>in row OKtocolour(boolean,int col,int color)</strong></p>
    <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Doloribus, illum odit. Voluptas, quis quasi magni ipsum sit dignissimos similique quisquam dolorem sed! Tempora hic nisi commodi tempore molestias harum odio.</p>
    <p>here is code for mthode one</p>
    <!------------iframeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee-->
    <pre style="color: rgb(23, 184, 184);">
        boolean explore1(int row, int column, int color) {

            if (row >= NUM_ROWS)return maplsOK();
            
            map[row][column] = color;
            
            for (int nextColor = RED; nextColor<= BLUE; nextColor++) {
            
            int[] next = nextRowAndColumn(row, column);
            
            if (explore1(next[0], next[1], nextColor)) return true;
            
            return false;
            
            </pre><br>
    <p>here is code for mthode two</p>
    <!------------iframeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee-->
    <pre style="color: rgb(23, 184, 184);">
        boolean explore1(int row, int column, int color) {

            if (row >= NUM_ROWS)return maplsOK();
            
            map[row][column] = color;
            
            for (int nextColor = RED; nextColor<= BLUE; nextColor++) {
            
            int[] next = nextRowAndColumn(row, column);
            
            if (explore1(next[0], next[1], nextColor)) return true;
            
            return false;
    </pre><br>
    <p>Lorem ipsum dolor sit Officia facere aut necessitatibus dolorem, quas ab neque pariatur mollitia quae, a, dignissimos saepe culpa nihil ullam esse. Rem architecto quisquam adipisci!</p>
    <table border="2" width="350px" height="150px" align="center">
        <tr>
            <th> </th>
            <th bgcolor="gray"> 2 by 3 map</th>
            <th bgcolor="gray"> 3 by 3 nap </th>
            <th bgcolor="gray"> 4 by 3 map</th>
        </tr>
        <tr>
            <th bgcolor="gray">methode 1</th>
            <td>60 ms</td>
            <td> 9400 ms</td>
            <td>60500</td>
        </tr>
        <tr>
            <th bgcolor="gray">methode 2</th>
            <td>0 ms</td>
            <td>0 ms</td>
            <td>0 ms</td>
        </tr>

    </table>
    <br>
    <p>
        Lorem ipsum dolor sit amet consectetur adipisicing elit. Earum non consequatur perspiciatis quae nemo veritatis unde. Iusto fuga voluptatibus totam eaque tempore earum repellendus nisi hic placeat sit reprehenderit accusantium, dignissimos sequi
         itaque at quaerat quasi culpa atque, neque voluptatum laborum delectus porro commodi. Veritatis tempore fugiat quod aliquid doloribus molestiae nihil nostrum, animi at perferendis modi beatae numquam quis hic consecteturcipit soluta placeat exercitationem sed, voluptatum fugit vel illum labore quisquam adipisci, dolor
        neque est corporis possimus animi ullam? Voluptatibus eum similique fugit laboriosam magnam ut laborum earum repudiandae dignissimos molestiae aut reprehenderit, veniam nihil ipsam, deleniti incidunt. Ipsum illum odit nihil, similique nemo vel, error 
        impedit quam explicabo doloremque atque facere sed possimus animi ullam? Voluptatibus eum .
    </p><hr>

<p style="font-weight: bold;">Debugging technique</p>



<p>Often our first try at a program doesn't work, and we need to debug it. Debuggers are helpful, but sometimes we need to fall back on inserting print statements. There are some simple tricks to making effective use of print statements. These tricks can be applied to any program, but are especially useful when you are trying to debug recursive routines</p>

<p><strong>Trick #1: Indent when you print method entries and exits.</strong></p>

<p>Often, the best debugging technique is to print every method call and return (or at least the most important ones). You probably wart to print, for each method, what parameters it came in with, and what value it leaves with However, if you just print a long list of these, it's hard to match up method exits with their corresponding entries. Indenting to show the level of nesting can help.

want to print, for each method, what parameters it came in with, and what value it leaves with. However, if you just print a long list of these, it's hard to match up method exits with their corresponding entries. Indenting to show the level of nesting can help.</p>

<strong>Trick #2: Use specialized print methods for debugging.</strong><br>
<p>
Don't clutter up your actual code more than you must. Also, remember that code inserted for debugging purposes can itself contain bugs, or (in the worst case) can affect the results, so be very careful with it.<br></p>

<p>Here's our debugging code. For this trivial program, there's almost more debugging code than actual code, but in larger programs the proportions will be better.</p>

<pre style="color: rgb(13, 207, 207);">
static String indent = "";
static String name(BinaryTree node) {
    if (node == null) return null;
    else return node.name;
}
static void enter(Binary Tree node) {
    System.out.println(indent + "Entering solvable(" + name(node) + ")");
    indent indent+" " =
}
static boolean yes(BinaryTree node) {
    indent indent.substring(3);
    System.out.println(indent + "solvable("+name(node) + ") returns true");
    return true;
}
static boolean no(Binary Tree node) {
    indent indent.substring(3);
    System.out.println(indent + "solvable("+name(node) + ") returns false");
    return false;
}</pre>

<p>To use this code, we modify solvable as follows:</p>



<pre style="color: rgb(18, 213, 213);">

static boolean solvable(Binary Tree node){

  enter(node);

  if (node == null) return no(node);

  if (node isGoalNode) return yes(node);

  if (solvable(node.leftChild)) return yes(node);

  if (solvable(node.rightChild)) return yes(node);

  return no(node);
} </pre> 

<pre>
<p>And we get these results:</p>
Entering solvable(Root)
| Entering solvable(A)
|| Entering solvable(C)
||| Entering solvable(null)
||| solvable(null) returns false
||| Entering solvable(null)
||| solvable(null) returns false
|| solvable(C) returns false
|| Entering solvable(D)
||| Entering solvable(null)
||| solvable(null) returns false
||| Entering solvable(null)
||| solvable(null) returns false
|| solvable(D) returns false
| solvable(A) returns false
| Entering solvable(B) 
|| Entering solvable(E)
|| solvable(B) returns true 
solvable(Root) returns true
true
</pre>


<strong>Trick #3: Never discard your debugging statements.</strong>

Writing debugging statements is programming, too. Often it's as much work to debug the debugging statements as it is to debug the actual program. Once your program is working, why throw this code away?<br>

Obviously, you don't want to print out all this debugging information from a program you are ready to submit (or to turn over to your manager). You could comment out your debugging calls, but that can be a lot of work. What's more, in the above example, you would have to replace every return(yes/node)) with return(true), and every return(no(node)) with return false. With all these changes, you might introduce new bugs into your program.<br>

The simple solution is to make your debugging statements conditional. For example,<br>

<pre style="color: rgb(14, 177, 177);">
static final boolean debugging = false;{

static void enter(Binary Tree node) {
  if (debugging) {
      System.out.println(indent + "Entering solvable(" + name(node) + ")");
      indent = indent + " ";
  }
}
static boolean yes(Binary Tree node) {
  if (debugging) {
      indent indent.substring(3);
      System.out.println(indent + "solvable(" + name(node) + ") returns true");
  }
  return true;
}

static boolean no(BinaryTree node) {

  if (debugging) {

      indent = indent.substring(3);

      System.out.println(indent + "solvable("+name(node)+") returns false");
  }
  return false;
}
</pre>
<br>
<p>Lorem ipsum dolor veniam provident aliquid esse ratione dolore sequi incidunt in, molestiae odio? Lorem ipsum dolor sit amet consectetur adipisicing elit. Consectetur amet numquam, temporibus recusandae voluptates necessitatibus similique nobis aperiam accusantium, vero suscipit excepturi. Nesciunt et voluptates explicabo ea quae! Eligendi, ratione.</p><br>
<strong>Trick #3: Create an Expections.</strong>
<p>Lorem ipsum dolor, sit amet consectetur adipisicing elit. Error officiis eius, voluptatem sequi aspernatur animi iste. In officiis beatae unde natus repudiandae eos rem veniam! Illum odio inventore magni! Rem aliquam aut nesciunt consectetur ab recusandae sint unde blanditiis beatae veritatis nobis deleniti aliquid fugit porro reiciendis quae assumenda amet, quidem officia repudiandae accusantium minima consequatur odit. Neque quas ipsum molestiae, pariatur accusantium officiis numquam, provident, dolore dolorem nostrum adipisci quo quos obcaecati atque praesentium.</p><br>
<pre style="color: rgb(18, 159, 159);">
    new Exception("Checkpoint Charlie").printstacktrace(system.out);
</pre>
<p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Odit quidem rerum iusto, saepe reiciendis beatae labore, laudantium doloribus quas ullam non veniam soluta at molestiae optio, eveniet eaque expedita deleniti! Print statement </p>
<br>
<pre style="color: rgb(27, 167, 167);">
java.lang.Exception: Checkpoint Charlie
  at TreeSearch.solvable(TreeSearch.java:53)
  at TreeSearch.solvable(TreeSearch.java:57)
  at TreeSearch.main(TreeSearch.java:72)
  at SHELL 38.run(SHELL38.java:16)

  at bluej.runtime.ExecServer.suspendExecution (Unknown Source)<hr></pre>

<strong> Examples:Cindy's Puzzle</strong>

<p>I call the following puzzle "Cindy's puzzle" for historical reasons. You have some number of black marbles and the same number of white marbles, and you have a playing board which consists simply of a line of 2n+1 spaces to put the marbles in. Start with the black marbles all at one end (say, the left), the white marbles all at the other end, and a free space in between.</p><br>


<p><strong>Starting position:</strong></p>
<table border="1" align="center" cellpadding="8">
    <tr>
        <td><img src="./projectpic3.png "/></td>
        <td><img src="./projectpic3.png "/></td>
        <td width="45"></td>
        <td><img src="./projectpic2.png" /></td>
        <td><img src="./projectpic2.png "/></td>
    </tr>
    
</table>   
<p>The goal is to reverse the positions of the marbles:</p>
<table border="1" align="center" cellpadding="8">
    <tr>
        <td><img src="./projectpic2.png "/></td>
        <td><img src="./projectpic2.png"/></td>
         <td width="45"></td>
        <td><img src="./projectpic3.png" /></td>
        <td><img src="./projectpic3.png" /></td>
    </tr>
    
</table>   
<b><p>The black marbles can only move to the right, and the white marbles can only move to the left (no backing up). At each move,<br> a marble can either:<p></b>
<ul style="list-style-type:disc" >
    <li>
        Move one space ahead, if that space is clear, or
    </li>
    <li>
        Jump ahead over exactly one marble of the opposite color, if the space just beyond that marble is clear.
    </li>
</ul>
<p>For example, you could make the following sequence of moves:</p>

 
<table align="center">
    <tr>
        <td>
        <b>starting position:</b>
        </td>
        <td><table border="1"  cellpadding="8">
            <tr>
                <td><img src="./projectpic3.png" ></td>
                <td><img src="./projectpic3.png" /></td>
                <td width="45"></td>
                <td><img src="./projectpic2.png "/></td>
                <td><img src="./projectpic2.png "/></td>
                
            </tr>
            
        </table>
    </td>
    </tr>
   <tr>
        <td>
        <b>Black moves ahead:</b>
        </td>
        <td><table border="1" cellpadding="8">
            <tr>
                <td><img src="./projectpic3.png "/></td>
                <td width="45"></td>
                <td><img src="./projectpic3.png"/></td>
                
                <td><img src="./projectpic2.png "/></td>
                <td><img src="./projectpic2.png "/></td>
                
            </tr>
            
        </table>
    </td>
    </tr>
    <tr>
        <td>
        <b>white jumps:</b>
        </td>
        <td><table border="1" cellpadding="8">
       <tr>
                <td><img src="./projectpic3.png "/></td>
                <td><img src="./projectpic2.png"/></td>
                <td><img src="./projectpic3.png"/></td>
                <td width="45"></td>
                
                <td><img src="./projectpic2.png "/></td>
                
            </tr>
            
        </table>
    </td>
    </tr>
    <tr>
        <td>
        <b>Black moves ahead:</b>
        </td>
        <td><table border="1" cellpadding="8">
            <tr>
                <td><img src="./projectpic3.png" /></td>
                <td><img src="./projectpic2.png "/></td>
                <td width="45"></td>
                <td><img src="./projectpic3.png "/></td>
                <td><img src="./projectpic2.png "/></td>
                
            </tr>
                  
        </table>
    </td>
    </tr>
    
    
    
    <tr>
        <td>
        <p><b>Black jumps:</b></p>
        </td>
        <td><table border="1" cellpadding="8">
            <tr>
                <td width="45"></td>
                <td><img src="./projectpic2.png" /></td>
                <td><img src="./Projectpic3.png "/></td>
                <td><img src="./Projectpic3.png" /></td>
                <td><img src="./projectpic2.png" /></td>
                
            </tr>
            
        </table>
    </td>
    </tr>
    <tr>
        <td>
        <p><b>White moves ahead:</b></p>
     </td>
        <td><table border="1" cellpadding="8">
            <tr>
                <td width="45"></td>
                <td><img src="./projectpic2.png" /></td>
                <td><img src="./Projectpic3.png "/></td>
                <td><img src="./Projectpic3.png" /></td>
                <td><img src="./projectpic2.png" /></td>
                
            </tr>
            
        </table>
    </td>
    </tr>
    <tr>
        <td>
        <p><b>Stuck!</b></p>
        </td>
        </tr>
</table>



<p>The backtracking method is named solvable and returns a boolean. In solvable we shall need to check whether we are at a leaf, which in this case means a position from which no further moves are possible. This isn't so easy.</p>

<p>Now to the program. The main program will initialize the board, and call a recursive backtracking routine to attempt to solve the puzzle. The backtracking routine will either succeed and print out a winning path, or it will fail, and the main program will have to print out the bad news.</p>

<p></p>The backtracking method is named solvable and returns a boolean. In solvable we shall need to check whether we are at a leaf, which in this case means a position from which no further moves are possible. This isn't so easy.</p>

<p>Each possible move will result in a new board position, and these new board positions are the children of the current board position. Hence to find the children of a node (that is, of a board position), we need only find the possible moves from that node. Remember that it is also highly desirable to find an ordering on these possible moves.</p>

<p>Here it is time to stop and take thought. To make progress, we must analyze the game to some extent. Probably a number of approaches would work, and what follows is based on the way worked it out. If you were to program this puzzle, you might find a different but equally valid approach.</p>

<p>First, notice that if a marble has a move, that move is unique: if it can move ahead one square, then it cannot jump. If it can jump, It cannot move ahead one square. This suggests that, to find the possible moves, we might assign numbers to the marbles, and check each marble in turn. When we have looked at all the marbles, we have looked at all the possible moves. This would require having a table to keep track of where each marble is, or else somehow "marking" each marble with its number and searching the board each time to find the marble we want. Neither alternative is very attractive.</p>

Next, notice that for a given board position, each marble occupies a unique space. Hence, instead of talking about moving a particular marble, we can talk about moving the marble in a particular space. If a move is possible from a given space, then that must be the only move possible from that space, because if the marble in that space has a move, it is unique. There is a slight complication because not every space contains a marble, but at least the spaces (unlike the marbles) stay in one place.</p>

<strong> we have a simpler ordering of moves to use in our program. Just check, in order, the 2n+1 spaces of the board. For each space, either zero or one moves is possible. With this understanding, we can write a boolean method canMove(int[] board, int position) which determines whether a move is possible from the given position:</strong>

<ul>
    <li> If the position is empty, no move is possible;</li>
    <li> If the position contains a black marble, the method checks for a move or jump to the right;</li>
    <li>If the position contains a white marble, the method checks for a move or jump to the left.</li>
</ul><br>

<p>We write another method <span style="font-weight: bold;">[] makeMove(int[] oldBoard, int position)</span> that will take a board and a position, make a move from that position, and return as its value a new board. (We could write this somewhat more efficiently by changing the old board, rather than creating a new one, but here we are more concerned with simplicity.) In technical jargon, makeMove is "applicative" rather than "mutative."</p>
<p>Along with canMove and makeMove,<span style="font-weight: bold;">we are using methods</span>  puzzleSolved and<span style="font-weight: bold;">printBoard with</span>  meanings that<br>
should be obvious.</p>
<pre style="color: rgb(23, 191, 191);">

    boolean solvable(int[] board) { 
        if (puzzleSolved (board)) {
          return true;
        }
        for (int position = 0; position < BOARD_SIZE; position++) {
           if (canMove(board, position)) {
             int[] newBoard = makeMove(board, position);       
             if (solvable(newBoard)) { 
                printBoard(newBoard);
        
                return true;
             }
            }
        }

</pre>

<p>here is some output from the program:</p>
<ol reversed >

   <li><b>WHITE WHITE WHITE_______BLACK BLACK BLACK </b></li>
   <li><b>WHITE WHITE WHITE BLACK _______BLACK BLACK</b></li>
   <li><b> WHITE WHITE_______BLACK WHITE BLACK BLACK</b></li>
   <li><b> WHITE _______ BLACK BLACK WHITE BLACK BLACK</b></li>
   <li><b> WHITE BLACK WHITE _______ WHITE BLACK BLACK</b></li>
   <li><b>WHITE BLACK WHITE BLACK WHITE _______BLACK</b></li>
   <li><b> WHITE BLACK WHITE BLACK WHITE BLACK_______</b></li>
   <li><b>WHITE BLACK WHITE BLACK _______BLACK WHITE </b></li>
   <li><b> WHITE BLACK _______BLACK WHITE BLACK WHITE</b></li>
   <li><b> _______BLACK WHITE BLACK WHITE BLACK WHITE</b></li>
   <li><b>BLACK _______WHITE BLACK WHITE BLACK WHITE</b></li>
   <li><b>BLACK BLACK WHITE _______WHITE BLACK WHITE </b></li>
   <li><b>BLACK BLACK WHITE BLACK WHITE _______ WHITE </b></li>
   <li><b>BLACK BLACK WHITE BLACK _______ WHITE WHITE </b></li>
   <li><b>BLACK BLACK _______BLACK WHITE WHITE WHITE </b></li>
   <li><b>BLACK BLACK BLACK _______WHITE WHITE WHITE</b></li>


</ol>
    
    

<strong>Notice that the solution is given in reverse order: BLACK starts out on the left and WHITE on the right, as in the last line. I've added line numbers to the actual output in order to emphasize this point. Backtracking always produces its results (sequence of choices) in reverse order; it is up to you, the programmer, to reverse the results again to</strong>




</body>
</html>